{"version":3,"sources":["components/AddCategory.js","helpers/getGifs.js","components/GifGridItem.js","components/GifGrid.js","hooks/useFetchGifs.js","GifExpertApp.js","index.js"],"names":["AddCategory","_ref","setCategories","_useState","useState","_useState2","Object","slicedToArray","inputValue","setInputValue","react_default","a","createElement","onSubmit","e","preventDefault","trim","length","cats","concat","toConsumableArray","type","value","onChange","target","getGifs","asyncToGenerator","regenerator_default","mark","_callee","category","url","resp","_yield$resp$json","data","gifs","wrap","_context","prev","next","encodeURI","fetch","sent","json","map","img","_img$images","id","title","images","downsized_medium","abrupt","stop","_x","apply","this","arguments","GifGridItem","className","src","alt","GifGrid","_useFetchGifs","loading","state","setState","useEffect","then","imgs","console","log","useFetchGifs","Fragment","GifGridItem_GifGridItem","assign","key","GifExpertApp","categories","AddCategory_AddCategory","GifGrid_GifGrid","ReactDOM","render","GifExpertApp_GifExpertApp","document","getElementById"],"mappings":"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","file":"static/js/main.4fff0f2c.chunk.js","sourcesContent":["import React, { useState } from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\n\r\nexport const AddCategory = ( { setCategories } ) => {\r\n\r\n    // Tiene que terner un tipo de estado\r\n    // Hay que poner un String vacío, porque si no sería undefined\r\n    const [inputValue, setInputValue] = useState('');\r\n\r\n    // Ahora con esta función que dispara el escribir en el campo, \r\n    // el input value va a ser el valor más reciente escrito\r\n    const handleInputChange = ( e ) => {\r\n        setInputValue( e.target.value );\r\n    };\r\n\r\n    const handleSubmit = (e) => {\r\n        // Para prevenir el comportamiento por defecto del formulario\r\n        e.preventDefault();\r\n\r\n        // console.log('Submit hecho');\r\n\r\n        // Usamos esta instrucción, porque no tenemos las categorías, \r\n        // como tenemos un callback con el estado anterior, somos capaces\r\n        // de usarla. \r\n        // Con inputValue somos capaces de cogeer el valor  que se mete\r\n        if (inputValue.trim().length > 2) {\r\n            setCategories( cats => [inputValue, ...cats] );\r\n            setInputValue('');\r\n        }\r\n\r\n    };\r\n\r\n    return (\r\n            <form onSubmit={ handleSubmit }>\r\n                <input \r\n                    type=\"text\"\r\n                    value={ inputValue }\r\n                    onChange={ handleInputChange }\r\n                />\r\n            </form> \r\n    )\r\n}\r\n\r\n// Con esto, hacemos que sea obligatorio pasar la función setCategories dentro de \r\n// propTypes. Ponemos un candado con la obligación de las funciones que hay que pasar\r\nAddCategory.propTypes = {\r\n    setCategories: PropTypes.func.isRequired\r\n}\r\n","\r\n\r\n\r\nexport const getGifs = async( category ) => {\r\n\r\n    const url = `https://api.giphy.com/v1/gifs/search?q=${ encodeURI( category ) }&limit=10&api_key=Dn8Xf6ixBpedtiC7J4sVlNZgGbMVjhbh`;\r\n    const resp = await fetch(url);\r\n    const {data} = await resp.json();\r\n\r\n    const gifs = data.map( img => {\r\n        return {\r\n            id: img.id,\r\n            title: img.title,\r\n            url : img.images?.downsized_medium.url,\r\n\r\n        }\r\n    });\r\n\r\n    return gifs;\r\n\r\n};","import React from 'react'\r\n\r\nexport const GifGridItem = ( {title, url} ) => {\r\n\r\n\r\n    return (\r\n        // Se pone en el div un className porque class es una palabra\r\n        // reservada de JavaScript, por lo que así no tenemos problema\r\n        // para usar esa palabra reserveda. Luego en el código fuente de la \r\n        // página web se ve como div class \r\n        <div className=\"card animate__animated animate__fadeIn\">\r\n            <img src={ url } alt={ title } />\r\n            <p>{ title }</p>\r\n        </div>\r\n    )\r\n}\r\n","import React from 'react';\r\nimport { useFetchGifs } from '../hooks/useFetchGifs';\r\n// import { getGifs } from '../helpers/getGifs';\r\nimport { GifGridItem } from './GifGridItem';\r\n\r\nexport const GifGrid = ({ category }) => {\r\n\r\n    // const [images, setImages] = useState([]);\r\n    const { data:images, loading } = useFetchGifs( category );\r\n    // Cada vez que este componente se ejecute, se actualizará toda la página\r\n    // Para eso usaremos el useEffect, pero estará en nuestro Custom Hook\r\n    \r\n\r\n    // const [count, setcount] = useState(0);\r\n\r\n    // Esto nos permite ejecutar código de manera condicional. Le decime que cuando se cargue\r\n    // la página por primera vez se ejecute getGifs().\r\n    // El [] es un array de dependencias, al no haber nada, \r\n    // le decimos que no hay ninguna dependencia, disparándose una única vez.\r\n    // Además, hay un warning que da la crossOriginIsolated. Que falta una depedency, category. \r\n    // Sería útil tenerla en cuenta no vayamos a cambiar la category en mitad de la ejecución\r\n    // y por tanto se tengan que cambiar las imágenes que muestra\r\n    // Por eso se lo ponemos dentro de [], para decirle que es una dependencia.\r\n    // Aunque en este caso, no se va a modificar\r\n    // useEffect( () => {\r\n    //     // Cuando el componente que es renderizado por la 1ª vez, que se ejecute\r\n    //     getGifs( category )\r\n    //         .then( setImages );\r\n    // }, [ category ] );\r\n\r\n\r\n\r\n    \r\n\r\n    // Lo hemos quitado porque así cuando un componente se tenga que refrescar, \r\n    // no reinicie el estado de todo el componente y se vuelva a ejecutar tan normal\r\n    // getGifs();\r\n\r\n    return (\r\n        <>\r\n            <h3 className='animate__animated animate__fadeIn'>{ category }</h3>\r\n\r\n            { loading && <p className='animate__animated animate__flash'>Loading</p> }\r\n\r\n            <div className=\"card-grid\">\r\n\r\n                {\r\n                    images.map( img => (\r\n                        <GifGridItem \r\n                            key={ img.id }\r\n                            // Cada una de las propiedades de IMG se mandan como props\r\n                            { ...img }\r\n                        />\r\n                    ) )\r\n                }\r\n\r\n            </div> \r\n            \r\n                {/* <h3>{ count }</h3>\r\n                <button onClick={ () => setcount( count + 1 ) }></button> */}\r\n                {/* Con esto estamos sacando las imágenes que hemos obtenido de la API */}\r\n                {/* <ol>\r\n                    {images.map( ({ id, title }) => (\r\n                        <li key={ id }>{ title }</li>\r\n                    ))}\r\n                </ol>*/}\r\n\r\n                {/* {\r\n                    images.map( img => (\r\n                        <GifGridItem \r\n                            key={ img.id }\r\n                            // Cada una de las propiedades de IMG se mandan como props\r\n                            { ...img }\r\n                        />\r\n                    ) )\r\n                } */}\r\n\r\n\r\n            \r\n        </>\r\n    );\r\n\r\n}\r\n","// Vamos a crear el primer Hook, los Hooks no son más que funciones\r\nimport { useState } from \"react\"\r\nimport { useEffect } from \"react/cjs/react.development\";\r\nimport { getGifs } from \"../helpers/getGifs\";\r\n\r\nexport const useFetchGifs = ( category ) => {\r\n\r\n    // Los Hooks también pueden tener estado\r\n    // Cuando se use por 1ª vez se verá esto\r\n    const [state, setState] = useState({\r\n        data: [],\r\n        loading: true\r\n    });\r\n\r\n    // Que se dispare la petición solo si nuestra categoría cambia\r\n    // Los useEffect no pueden ser async, porque esperan algo síncrono\r\n    useEffect( () => {  \r\n\r\n        getGifs( category )\r\n            .then( imgs => {\r\n\r\n                console.log(imgs);\r\n                setState({\r\n                    data: imgs, \r\n                    loading: false,\r\n                });\r\n\r\n            } )\r\n            // Solo evaluaremos esto cuando la categoría cambie\r\n    }, [category]);\r\n\r\n    // Funcionan los Hooks como si fueran Functional Components\r\n    // setTimeout( () => {\r\n    //     setState({\r\n    //         data: [1, 2, 3, 4, 5],\r\n    //         loading: false,\r\n    //     })\r\n    // }, 3000 );\r\n\r\n    return state; // {data: [], loading: true};\r\n\r\n}\r\n","import React, { useState } from 'react';\r\nimport { AddCategory } from './components/AddCategory';\r\nimport { GifGrid } from './components/GifGrid';\r\n\r\n// GifExpertApp\r\n// <h2>GifExpertApp</h2>\r\n// <hr/>\r\n\r\nexport const GifExpertApp = () => {\r\n\r\n    // const categories = ['One Punch', 'Samirai X', 'Dragon Ball'];\r\n    const [categories, setCategories] = useState(['One Punch']);\r\n\r\n    // const handleAdd = () => {\r\n    //     // No se puede hacer esto porque se rompe. \r\n    //     // Y se rompe porque estoy eliminando el objeto que tenía antes y pongo \r\n    //     // solo un objeto.\r\n    //     // setCategories('HunterXHunter');\r\n    //     // De esta manera sí que funciona, porque le estoy diciendo que quiero hacer un \r\n    //     // un array con los elementos anterior y añadir el HunterXHunter\r\n    //     setCategories( [...categories, 'HunterXHunter'] );\r\n\r\n    //     // Esto se puede hacer también\r\n    //     // setCategories( cats => [...cats, 'HunterXHunter'] );\r\n\r\n    // };\r\n\r\n    return (\r\n        <>\r\n            <h2>GifExpertApp</h2>\r\n            <AddCategory setCategories={ setCategories } />\r\n            <hr/>\r\n\r\n            {/* Quiero poner una lista con las categorías */}\r\n            <ol>\r\n                {\r\n                    // El índice tiene que ser único, por loq ue es importante hacer algo\r\n                    // para que no tenga números duplicados\r\n                    categories.map( category => (\r\n                        // <li key={ category }> { category } </li>\r\n                        <GifGrid \r\n                            key={ category }\r\n                            category={ category } \r\n                        />\r\n                    ))\r\n                }\r\n            </ol>\r\n\r\n        </>\r\n    );\r\n}\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { GifExpertApp } from './GifExpertApp';\n\nimport './index.css';\n\n\nReactDOM.render(\n    <GifExpertApp />,\n  document.getElementById('root')\n);\n\n\n\n"],"sourceRoot":""}